## [JavaScript Practices](https://github.com/kickscar/javascript-practices) / [ch03](https://github.com/kickscar/javascript-practices/tree/master/ch03) / 01. 변수와 상수

#### 1-1. 변수(Variable)

1. 프로그램은 지속적으로 어떤 목적하에 데이터를 특정 비즈니스 로직(알고리즘)에 의해 변화 시키는 과정이라 볼 수 있다.

2. 테이터는 값(value)이라 말할 수 있다. 프로그램에서 다루는 데이터 즉, 값의 종류는 다양하기 때문에 다양한 프로그래밍 언어에서는 다양한 데이터 타입을 지원하고 있다.

3. 변수는 특정 목적의 알고리즘에 의해 변화되는 값이다. 값의 변화를 지속시키기 위해서 프로그램에서는 값에 이름을 붙히고 그 이름의 값을 변화시키는 것이다. 그래야 값의 변화를 알 수 있으니깐 말이다. 

4. 간단히 말하면 변수는 이름이 붙은 값이라 보면 된다. 다음 두 줄 코드로 약간 복잡하게 말해보자.

   ```
   int i = 10; // C, C++, Java 
   let i = 10; // JavaScript(ES6)
   ```

   - 엄밀히 구분하면, `i` 는 변수 이름이다. 

   - `10`이 변수이며  `10`은 어떤 알고리즘에 의해 변할 수 있는 값이다.

   - 보통은 `i` 를 가리켜 변수라 하지만 `i` 라는 이름이 붙은 **어떤 공간**에 저장된 값(10)이 바뀐다 하는 것이 맞는 표현이다.

   - **어떤 공간**은 컴퓨터의 **메모리 특정 영역**이 될 것이다. 

   - **메모리 특정 영역**은 저장되는 값의 종류(**데이터 타입**)에 따라 그 크기가 다르게 할당된다. 

   - 중요한 것은 프로그램 코드가  `10` 이라는 값이 저장된 **메모리 특정 영역**에 접근하기 위해 **메모리 주소**를 사용한다는 것이다.

   - 정리하면, `i` 라는 **변수 이름**은 저장할 값의 데이터 타입 크기 만큼 할당된 **메모리 공간의 주소** 이다.  프로그램 코드는 `i` 라는 이름으로 매핑된 **메모리 주소**에 할당된 공간에 저장된 `10`을 변화 시키는 것이다.

   - C 에서는 변수 이름은 메모리 주소에 대한 Symbolic Name이 되며 컴파일(링크) 또는 실행 시 실제 메모리 주소로 매핑된다.

   - 하지만, JavaScript 코드를 실행하는  JavaScript 엔진은 자신을 구현한 언어(보통은 C, C++ 또는 Java) 가 제공하는 API 라이브러리의 제약을 받기 때문에 앞의 설명 내용으로 변수를 다룰 수 없다. 그 보다 상위 레벨에서 변수 이름과 저장 공간을 관리하도록 구현해야 할 것이다.

   - ECMAScrip 표준은 엔진 구현에 대한 언급은 전혀 없다. 단지, 변수와 관련해서 다음 것들을 언급한다. 

     - 변수는 바뀌는 값에 대한 이름이다. 
     - 변수 이름의 작명 규칙(식별자 규칙)
     - 변수 이름으로 저장할 데이터의 타입

     즉, ECMAScript 표준이 정한 다양한 데이터 타입의 값을 ECMAScript 표준의 규칙대로 변수 이름을 짓고, 그 이름으로 값에 접근해서 그 값을 사용자 개발 로직(알고리즘)에 의해 바꿀 수 있도록 JavaScript 엔진이 구현되어야 한다.

   - 참고로 엔진 구현에서는 해시테이블을 사용한다. 변수 이름의 문자열을 해시키로 사용하고 그 키에 매핑된 32비트의 공간에 해당 변수의 정보(타입, 레퍼런스 또는 실제값)을  저장하도록 구현한다. 이 내용은 뒤의 데이터 타입을 설명할 때도 언급되는 내용으로 꼭 기억하도록 한다.

     

#### 1-2. 식별자(Identifier)

1. 프로그램은 여러 값을 다루는 것이 일반적이다. 여러 값을 식별(구분)해야 하기 때문에  값에 붙는 이름, 즉 변수 이름을 식별자(identifier)라 부른다.
2. 구분해야 할 것들은 변수 이름 뿐만이 아니다. 함수 이름, 클래스 이름, 모듈 이름 등을 어휘적 범위와 실행 범위에 따라 구분해야 할 필요가 있다. 따라서 변수 이름뿐만 아니라 함수 이름, 모듈 이름, 클래스 이름들도 식별자다. 쉽게 말하면,  코딩 시 작명 때문에 고민하는 것들이 대부분 식별자다.
3. JavaScript의 식별자의 문법적 규칙은 $를 식별자에 사용할 수 있다는 것만 빼고 Java와 완전 동일하다.
   - a-z, A-Z, 0-9, _, $ 로 구성 된다.
   - 식별자 시작으로 숫자가 올 수 없다.
   - 예약어는 사용할 수 없다. (사용할 수 있는 방법은 있지만, 사용할 이유가 특별나게 없으면 꾸역꾸역 사용하지 말자.) 
   - 유니코드를 사용할 수 있기 때문에 한글도 사용할 수 있다. (세계적 오픈소스가 될려면 이것도 꾸역꾸역 사용하지 말자.)
4. 문법적 규칙은 아니지만 식별자의 관례(Convention)는 다음과 같다.
   - 카멜(Camel) 케이스와 스네이크(Snake) 케이스 중에 보통 카멜 케이스를 선호한다.
   - 처음 시작을 대문자로 하지 않는다. 대문자는 생성자 함수 또는 클래스(ES6) 이름에만 사용한다.
   - 처음 시작을 _ 로 하는 것은 클래스내의 private 속성, 메소드 작명에 쓰인다. 보통 라이브러리 작성 시, 외부로 들어내고 싶지 않은 변수나 함수 이름에 붙히곤 한다.
   - 처음 시작을 $로 하는 것은 jQuery 객체의 변수 이름에 많이 쓰인다. 



#### 1-3. 리터럴(Literal)

1. literal의 사전적 의미는 ''문자그대로" 란 뜻이다. 프로그래밍에서는 소스 코드상에 문자 그대로 표현한 값을 변수로 저장한다는 의미로 이해해 볼 수 있다.  

2. 프로그램에서 변수로 저장하는 값들 중에 두 개 정도만 리터럴로 표현해보자.

   - 숫자 값을 문자 그대로 표현하면 `10`, `20`, `30` 이렇게 문자로 표현된다. 
   - 문자열 값을 문자 그대로 표현해 보면 `'hello'`, ` "JavaScript is Awesome"` 이렇게 표현된다. 
   - 문자열 리터럴을 위해 `"` 또는 `'`를 사용했는 데,  JavaScript is Awesome 문장만 보면 공백 문자까지 포함하는 문자열이 하나의 문자열 값이다. 따라서 공백 문자까지 포함시키기 위해 따옴표를 사용한다.
   -  `"` 또는 `'`  는 뒤에 자세히 설명하겠지만 리터럴과 식별자를 구분하는 역할도 한다. 

3. 변수 이름에 값을 대입(assignment, = 연산자) 할 때, 함수와 같은 어떤 로직을 담은 코드로 대입도 가능하지만 소스 코드상에 리터럴 대입도 가능하다. 여기서 값과 리터럴의 차이를 이해하는 것도 중요하다.

4. 리터럴 단어 자체는 소스 코드의 정적(lexical) 구조에서의 의미가 더 크다. 코드가 실행될 때에는 문자로 표현된 리터럴은 변수로 저장되는 값인 데이터가 된다. 위의 1-1 변수 예제 코드에서 `i`라는 변수 이름으로 숫자 값 저장을 위해 `10` 이라는 숫자형 리터럴을 사용했다고 설명할 수 있다.

5. JavaScript의 좋은 것(Good Parts) 중에 하나는 리터럴이 풍부하다는 것이다. [ch03/02. 데이터 타입](/kickscar/javascript-practices/tree/master/ch03/02) 에서 다루겠지만 각각의 데이터 타입마다 다양한 리터럴을 지원한다.

6. **변수**의 개념, 변수 이름을 짓기 위한 **식별자** 그리고 값을 변수로 저장하기 위한 문자 표현, **리터럴**을 모두 언급 했기 때문에 실제 변수로 값을 저장하는 대입 구문(Assignment Statement)을 작성 할 수 있게 되었다.

7. [실습: project-ex01] 리터럴 사용한 대입 구문 : ex01.js

   ```JavaScript
   n = 10;
   f = 3.14;
   s = 'JavaScript is Awesome';
   b = true;
   
   console.log(n, f, s, b);
   ```

   - 가끔, Syntax를 우리말로 구문이라 잘못 해석하는 것을 볼 수 있다.
     - Syntax는 코드의 구조 또는 형태를 가리키는 말로 문법 그 자체로 이해하면 된다. 예를 들어, 대입 구문의 구조는 이항 연산자 = 를 가운데 두고 왼쪽, 오른쪽 항이 두개 있는 구조로 문법을 정해 놓은 것을 Assignment Statement(대입 구문)에 대한 Syntax(구조 또는 문법)라 말하는 것이다. 이를 지키지 않으면 컴파일러나 인터프리터에서 Syntax Error를 일으키는 것을 경험했을 것이다.
     - 위의 Syntax 예를 더 정확히 하면, 왼쪽 항은 변수 이름어야 하고 오른쪽 항은 값에 대한 표현식(Expression) 이어야 한다. 여기서 또 중요한 것은 표현식(Expression)과 구문(Statement)를 구분할 줄 알아야 한다. 
     - 위의 예제는 값에 대한 표현식중에 가장 간단한 리터럴을 사용했다.   
   - 구문(Statement) 은 실제 컴파일 단위, 또는 실행 단위 이다. 
   - JavaScript에서는 개행(\\n) 또는 세미콜론(;) 으로 구문을 구분해서 구문 하나씩 실행 시킨다. (사실, 구문의 구성요소인 토큰이라는 것으로 더 작게 쪼개서 실행해 나간다.)
   - 위의 코드는 세미콜론이 없어도 실행이 되지만 가능한 세미콜론으로 구문을 구문하도록 하자.
   - 숫자값 리터럴, 문자열 리터럴 그리고 불리언값 리터럴을 사용해서 각각의 변수 이름으로 저장하고 변수 이름으로 저장한 값을 다시 읽어와 출력한다.    

8. [실습: project-ex01] 리터럴과 식별자의 구분 : ex02.js

   ```javascript
   caffeAmericano = 4100;
   orderPrice = caffeAmericano;
   orderMenu = "caffeAmericano";
   ```

   - 자바스크립트는 따옴표를 통해 리터럴과 식별자를 구분한다.

   - 식별자는 숫자로 시작할 수 없는 식별자 규칙이 있기 때문에 숫자는 따옴표를 붙히지 않는다.

   - 1번 라인 : 4100은 숫자 4 시작하기 때문에 식별자가 될 수 없으므로 따옴표를 못 붙힌 것이다. (코딩할 때는 4100 이라는 숫자 리터럴 값을 의도했기 때문에 당연히 안 붙힌 것이 맞겠지만 문법적으로 보면 못 붙힌것이고 리터럴이 되어야 하는 것이다.)

   - 2번 라인 : 숫자로 시작하지 않는 문자열에 따옴표를 붙히지 않으면 식별자이기 때문에 해당 식별자 이름의 변수 caffeAmericano 저장된 값 4100이 대입된다.

   - 3번 라인 : 따옴표를 붙혀 문자열 리터럴이 되었기 때문에 orderMenu에는 "caffeAmericano" 가 저장된다.

     

#### 1-4. let과 const 그리고 var

1. 예제 ex03.js 로 변수의 선언과 변수의 정의를 구분 해보자.

2. [실습: project-ex01] 변수의 선언과 정의  : ex03.js 

   ```javascript
   x;
   var y;
   var z = 10;
   
   console.log(y, z);
   ```

   - 1번 라인은 오류다.  변수를 선언한 것이 아니라 식별자 표현식으로만 된 구문이다. 이 구문의 실행에서 존재하지 않는 변수 x가 있기 때문에 Reference Error 가 발생한다.

   - 따라서, 변수를 구문에서 사용하기 전에는 반드시 변수를 선언 또는 정의해야 한다. JavaScript 에서는 `let`, `const`, `var` 키워드를 사용해 변수의 선언 또는 정의를 할 수 있다.

   - 2번 라인은 변수에 값을 할당하지 않고 식별자로 변수의 이름만 부여 하였기 때문에 변수의 선언이 된다.

   - 3번 라인은 식별자로 변수의 이름을 부여하고 그 이름에 값을 할당 하였기 때문에 변수의 정의가 된다.

   - C 와 같은 언어는 선언과 정의를 구분하는 대표적 언어이다.

   - 출력 결과를 보면 y 가 `undefined` 로 출력된다.  [ch03/02. 데이터 타입](/kickscar/javascript-practices/tree/master/ch03/02) 에서 다루는 내용이지만 `undefined`는 자바스크립트 기본 타입중에 하나로 값을 명시적으로 대입하지 않았지만 `undefined` 가 암시적으로 대입되었다. 아래 코드처럼 명시적 대입도 가능하지만 굳이 하지 않는다.

     ```javascript
     var y = undefined;
     ```

   - 따라서 JavaScript에서는 변수의 선언과 변수의 정의를 구분하지 않는다. 즉, 2번 라인도 정의로 보는 것이 JavaScript에서는 맞다.

3. 일반적으로 프로그램 실행 흐름에서 변수를 정의하게 되면 변수가 그 때부터 존재하게 된다.

4. 보통, 변수의 존재 범위를 스코프(Scope, 범위) 라고 한다. 소스 코드만 보면 변수가 어떤 스코프인 지 판단할 수 있는 스코프를 정적 스코프라 한다.  JavaScript는 정적 스코프이다.

5. 문제는 소스 코드에 보이는 스코프와 프로그램 실행 흐름에서 생겨나는 스코프가 차이가 있다는 것이다. JavaScript 스코프는 처음부터 혼란스럽고 이해하기 만만치 않은 개념들도 있다. 자세한 내용은 [ch05 스코프(Scopre)](/kickscar/javascript-practices/tree/master/ch05) 를 참고 한다.

6. JavaScript의 정적 스코프는 전역 스코프(Global Scope), 블록 스코프(Block Scope), 함수 스코프(Function Scope)에 적용된다.  JavaScript의 변수는 이 세 가지 스코프를 가질 수 있다는 말이다.

7. `var` 키워드는 변수를 함수 내부(`{}` 블록 안) 에만 존재하는 함수 스코프를 가지도록 하는 키워드이다. 변수를 함수 내부에서 `var` 와 함께 정의하면,  함수 내부에서만 그 변수는 존재한다. `var`와 함께 정의하지 않으면 전역 스코프를 가져 프로그램 아무데서나 그 변수에 접근이 가능해지는 문제점을 낳게 한다.(전역 스코프가 반드시 나쁜 것은 아니지만 결국에는 좋지 못한 문제점을 발생시킨다.)

8. `var` 를 사용하지 않고 함수 내부에서 변수를 정의 했을 때 전역 스코프를 가지는 문제점과  `var` 의 작동 원리 Hoisting이 가지는 혼란스러움 때문에 ES6에서는 새롭게 `const`와 `let`을 사용하여 변수를 정의하도록 하였다. 이 두 키워드는 ES6 전까지는 없었던 블록 스코프를 가지도록 한다.

9. 간단히 정리하면, `let`과 `const`를 사용해서 변수를 정의하라는 것이고 자세한 그 이유는 [ch05 스코프(Scopre)](/kickscar/javascript-practices/tree/master/ch05) 참고한다.

10. 두 키워드 중  `let`은 변수 정의에 사용한다. `const`는 정의한 후 값이 변하지 않는 상수 정의에 사용한다.

11. 상수 정의 후, 값 대입을 다시 하면  Assignment to constant variable 오류가 발생한다.

    [실습: project-ex04] 상수 정의 및 오류  : ex03.js

    ```javascript
    const n = 10;
    n = 20;
    ```

    ![](http://image.kickscar.me:8080/markdown/javascript-practices/ch03-0001.png)

    