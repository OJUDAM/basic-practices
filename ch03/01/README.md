## [JavaScript Practices](https://github.com/kickscar-javascript/basic-practices) / [ch03](https://github.com/kickscar-javascript/basic-practices/tree/master/ch03) / 01. 변수와 상수

### 1. 변수(Variable)

​	프로그램은 지속적으로 어떤 목적을 가지고 데이터를 특정 알고리즘에 의해 변화 시키는 과정이라 볼 수 있다. 프로그램에서 다루는 데이터 즉, 값(Value)의 형태는 다양하기 때문에 보통 프로그래밍 언어에서는 다양한 데이터 타입을 지원하고 있다.

​	변수는 프로그램 실행 중에 특정 알고리즘에 의해 변화되는 값이다. 값을 변화시키고 변화된 상태를 유지하기 위해서는 값만 존재해서는 안된다. 값에 어떤 이름을 붙히고 그 이름의 값을 변화 시켜야 값의 변화를 지속적으로 유지하면서 출력하거나 또는 다른 알고리즘에서 사용하기도 할 것이다. 요약하면, 변수는 이름이 붙은 값이라 할 수 있다. 다음 두 줄 코드로 약간 더 복잡하게 설명해 보자.

```
int i = 10; // C, C++, Java 
let i = 10; // JavaScript(ES6)
```

​	엄밀히 구분하면, `i` 는 변수 이름이다. `10`이 변수이며  `10`은 어떤 알고리즘에 의해 변할 수 있는 값이다. 보통은 `i` 를 가리켜 변수라 하지만 `i` 라는 이름이 붙은 **어떤 공간**에 저장된 값(`10`)이 바뀐다 하는 것이 맞는 표현이다.

​	한편, **어떤 공간**은 컴퓨터의 **메모리 특정 영역**이 될 것이다. 왜냐하면 값이 데이터로 저장될 수 있는 곳은 컴퓨터에서는 메모리 밖에 없기 때문이다. **메모리 특정 영역**은 저장되는 값의 형태(**데이터 타입**)에 따라 그 크기가 다르게 할당된다. 중요한 것은 프로그램 코드는  `10` 이라는 값이 저장된 **메모리 특정 영역**에 접근하기 위해 **메모리 주소**를 사용한다는 것이다.

​	정리하면, `i` 라는 **변수 이름**은 저장할 값의 데이터 타입 크기 만큼 할당된 **메모리 공간의 주소** 이다.  프로그램 코드는 `i` 라는 이름으로 매핑된 **메모리 주소**에 할당된 메모리 영역에 저장된 `10`을 변화 시키고 저장하는 것이다.

​	C 프로그래밍 언어에서는 변수 이름은 메모리 주소에 대한 심볼(Symbolic Name)이 되며 컴파일(링크) 또는 실행 때에 실제 메모리 주소로 매핑된다. 하지만, JavaScript 코드를 실행하는 JavaScript 엔진은 구현한 언어(보통은 C, C++ 또는 Java) 가 제공하는 API 라이브러리의 제약을 받기 때문에 앞의 C가 하는 것처럼 변수를 생각할 수 없다. 그 보다 상위 레벨에서 변수 이름과 메모리 영역을 관리하도록 구현되어 있기 때문이다.

​	ECMAScript 표준은 엔진 구현에 대한 언급은 전혀 없다. 단지, 변수와 관련해서 다음 것들을 언급한다.

1. 변수는 바뀌는 값에 대한 이름이다. 
2. 변수 이름의 작명 규칙(식별자 규칙)
3. 변수 이름으로 저장할 데이터의 타입

​	ECMAScript 표준이 정한 다양한 데이터 타입의 값을 ECMAScript 표준의 규칙대로 변수 이름을 짓고, 그 이름으로 값에 접근해서 알고리즘이 구현된 JavaScript 코드가 그 값을 바꿀 수 있도록 JavaScript 엔진이 구현되어야 한다. 

​	참고로 몇몇 JavaScript 엔진의 구현을 보면 이 부분에서 해시테이블을 사용하는 것을 볼 수 있다. 변수 이름의 문자열을 해시키로 사용하고 그 키에 매핑된 32비트(또는 64비트)의 공간에 해당 변수의 정보(타입, 레퍼런스 또는 실제값)을  저장하도록 구현한다. 이 내용은 뒤의 데이터 타입을 설명할 때도 언급되는 내용으로 실제 엔진 구현 코드를 예로 들어 자세히 설명한다.



### 2. 식별자(Identifier)

​	프로그램은 여러 값들을 다룰 것이다. 따라서 여러 값을 식별(구분)해야 할 필요성이 있다. 이런 이유로  값에 붙는 이름, 즉 변수 이름을 식별자(identifier)라 한다. 구분해야 할 것들은 변수 이름 뿐만이 아니다. 함수 이름, 클래스 이름, 모듈 이름 등을 어휘적 범위와 실행 범위에 따라 구분해야 할 필요가 있다. 따라서 변수 이름뿐만 이런 것들도 모두 다 식별자다. 다르게 말하면, 코딩할 때 작명 때문에 고민하는 것들이 대부분 식별자라 보면 된다.

JavaScript의 식별자의 문법적 규칙은 $를 식별자에 사용할 수 있다는 것만 빼고 Java와 완전 동일하다.

1. a-z, A-Z, 0-9, _, $ 로 구성 된다.
2. 식별자 시작으로 숫자가 올 수 없다.
3. 예약어는 사용할 수 없다. (사용할 수 있는 방법은 있지만, 사용할 이유가 특별나게 없으면 꾸역꾸역 사용하지 말자.) 
4. 유니코드를 사용할 수 있기 때문에 한글도 사용할 수 있다. (세계적 오픈소스가 될려면 이것도 꾸역꾸역 사용하지 말자.)

문법적 규칙은 아니지만 식별자의 관례(Convention)는 다음과 같다.

1. 카멜(Camel) 케이스와 스네이크(Snake) 케이스 중에 보통 카멜 케이스를 선호한다.

2. 처음 시작을 대문자로 하지 않는다. 대문자는 생성자 함수 또는 클래스(ES6) 이름에만 사용한다.

3. 처음 시작을 _ 로 하는 것은 클래스내의 private 속성, 메소드 작명에 쓰인다. 보통 라이브러리 작성 시, 외부로 들어내고 싶지 않은 변수나 함수 이름에 붙히곤 한다.

4. 처음 시작을 $로 하는 것은 jQuery 객체의 변수 이름에 많이 쓰인다. 

   

### 3. 리터럴(Literal)

​	literal의 사전적 의미는 ''문자그대로" 란 뜻이다. 프로그래밍에서는 코드상의 문자 그대로 표현된 값을 메모리 어딘가에 저장한다는 의미로 이해해 할 수 있다.  코드상의 문자 그대로 표현된 값들 중에 두 개 정도만 리터럴로 표현해보자. 숫자 값을 문자 그대로 표현하면 `10`, `20`, `30` 이렇게 문자로 표현된다. 문자열 값을 문자 그대로 표현해 보면 `'hello'`, ` "JavaScript is Awesome"` 이렇게 표현된다. 

​	문자열 리터럴은  `"` 또는 `'`를 사용하는 데, ` JavaScript is Awesome` 문장만 보면 공백 문자까지 포함하는 문자열이 하나의 문자열 값이다. 따라서 공백 문자까지 포함시키기 위해 따옴표를 사용한다. 그런데 이 설명이 크게 잘못된 것은 아니지만 저장할 값 자체에 의미를 둔 설명이다.  `"` 또는 `'`  를 쓰는 이유는 리터럴과 식별자를 구분하기 위해서라고 하는 것이 프로그래밍의 문법적인 이유다. 예제로 더 자세히 살펴보자.

#### 3.1 리터럴과 식별자의 구분 : ex01.js

```javascript
caffeAmericano = 4100;
orderPrice = caffeAmericano;
orderMenu = "caffeAmericano";
```

​	JavaScript는 따옴표를 통해 리터럴과 식별자를 구분한다. 식별자는 숫자로 시작할 수 없는 식별자 규칙이 있기 때문에 숫자로 시작한다면 따옴표로 구분할 필요없이 무조건 리터럴로 취급한다. 라인 별로 차근차근 보자.

1. 1번 라인

   4100은 숫자 4로 시작하기 때문에 무조건 리터럴이다. `=` 연산자의 오른쪽 항은 값이어야 하기 때문에 문제가 없다. 왼쪽 항caffeAmericano는 숫자로 시작하지 않고 따옴표가 안 붙어 있기 때문에 식별자가 되어 왼쪽 항의 숫자 값 4100을 저장하는 변수 이름이 된다.

2. 2번 라인

   숫자로 시작하지 않는 문자열에 따옴표를 붙히지 않으면 식별자이므로 식별자 caffeAmericano 라는 변수 이름이 되어 값 4100을 표현하며 이 값이 왼쪽 항으로 대입될 것이다. 왼쪽 항도 숫자로 시작하지 않고 따옴표도 없기 때문에 식별자가 되어 orderPrice라는 변수 이름으로 오른쪽 항의 값 4100을 저장 할 것이다.

3. 3번 라인

   따옴표를 붙혔기 때문에 오른쪽 항은 문자열 리터럴이다. 왼쪽 항은 2번 라인과 마찬가지로 숫자로 시작하지 않고 따옴표도 없기 때문에 식별자가 되어 orderMenu라는 변수 이름으로 오른쪽 항의 문자열 리터럴 값 "caffeAmericano" 를 저장할 것이다.

​	코드상에서 리터럴이 사용될 수 있는 곳은 예로 제시할 수 없을 만큼 많다. 다만, 리터럴은 **표현식(Expression)** 중에 하나고 표현식이 사용될 수 있는 곳이면 어디서나 사용될 수 있다는 것만 기억하면 될 것 같다.

​	표현식이라는 용어를 처음 사용하였는데 표현식에 대한 이해를 돕기 위해 간단한 예를 들어 설명해보자. `2+2` 라는 `더하기 산술 연산자 표현식`(Addition Arithmetic Operator Expression)은 4라는 `값`(value)을 표현하는 `표현식` 이다. 표현식  `2+2` 가 사용되는 곳은 `값` 4의 또 다른 `리터럴 표현식`인  `4`로 대체할 수 있다. 

​	이 예에서 이미 느껴겠지만, 먼저 따져보아야 할 것이 값과 리터럴의 구분이다. 시작부터 계속 언급해 오고 있지만 값은 메모리에 저장되는 데이터 그 자체이지만 코드상에서는 그 값을 다양하게 표현할 수 있다. `값` 4를 JavaScript 코드의 표현식으로 표현해보고 값과 리터럴의 차이 그리고 표현식도 이해해 보자.  

#### 3.2 `값` 4에 대한 다양한 `표현식` : ex02.js

```JavaScript
2 + 2
parseInt('4')
Math.pow(2, 2)
4
i = 4
i
```

​	특정 한개의 값으로 평가(evalue)될 수 있는 JavaScript 코드를 표현식이라 한다. 예제의 `값` 4를 표현하는 다양한 표현식을 하나씩 살펴 보자.

1.  2 + 2 는 더하기 산술 연산자 `+` 표현식으로 연산 결과가 4를 표현한다. 
2. 2번, 3번 라인은 함수 호출 연산자 `()` 표현식으로 함수를 호출하면 4를 반환하기 때문에 4를 표현한다.
3. 4번 라인이 바로 리터럴 표현식이다. 표현식 중에 가장 직관적이라 볼 수 있다.
4. 5번 라인은 대입 연산자 `=`표현식으로 대입 연산이 평가되면 변수` i`에 값 4가 저장된다. 그리고  `i` 자체로 값 `4`를 표현할 수 있다. 확인해 보는 방법은 console.log와 같은 함수의 파라미터로 이 표현식을 넣어서 호출해 보는 것이다. log함수는 파라미터로 값을 넘겨야 한다. 
5. 5번 라인의 대입 표현식이 어떻게든 어떤 실행에서 평가가 된다면, ` i` 변수는  `값` 4를 표현하는 표현식이 된다. 즉, 변수도 변 수 이름으로 저장된 값을 표현하는 표현식이다.

​	예제를 통해 표현식으로 특정 하나의 값을 다양하게 표현할 수 있음을 확인하였다. 리터럴은 그 표현식들 중에 가장 직관적으로 값에 대한 표현한다. 리터럴이라는 단어 자체는 코드의 문법(lexical) 체계에서 의미를 두고 이해하는 것이 좋다. 실제로 리터럴 표현식이 포함된 구문이 실행되고 표현식이 평가되면 문자로 표현된 리터럴은 메모리 어딘가에 저장되는 데이터가 된다.

​	 JavaScript의 좋은 것(Good Parts, 더글라스 크라포드) 중에 하나는 리터럴이 풍부하다는 것이다. [ch03/02. 데이터 타입](/kickscar-javascript/basic-practices/tree/master/ch03/02) 에서 다루겠지만 데이터 타입마다 다양한 리터럴을 소개하도록 한다.

​	그리고 예제를 보면 라인끝에 세미콜론 `;` 를  일부러 넣지 않은 것을 발견할 수 있다. 붙히게 되면 구문이 되기 때문에 표현식 자체의 의미부여를 위해 붙히지 않았다.  그래도 실행에는 아무 문제가 없는 온전한 JavaScript 코드이다. 방금 `실행`이라 했는데,  JavaScript의 실행 단위는 **구문(또는 문장, Statement)**이다. 그러면 표현식으로만 되어 있는 예제 코드는 엔진에서 `실행`은 되는 것인가? 실행된다면 어디서 부터 어디까지 어떤 단위로 실행 될까? 

​	이런 질문에 대답 할 수 있어야 한다. 왜냐하면 프로그램 코드의 가장 상위 카테고리인 표현식과 구문을 언급한 것으로 프로그램 코드 구조의 근간이 되는 기초적인 개념들이다. 하지만, 이 둘의 개념 이해와 구분은 그리 만만한 주제가 아니다. 특히 JavaScript에서는 전반적인 언어에 대한 이해가 있어야 온전히 이해할 수 있을 것 같다.

### 4. 표현식(Expression)과 구문(Statement)

#### 4.1 구문

처음 변수 설명을 시작하면서 "프로그램은 지속적으로 어떤 목적을 가지고 데이터를 특정 알고리즘에 의해 변화 시키는 과정이라 볼 수 있다" 고 나름 프로그램에 대한 정의를 내렸다. 프로그램은 이 "특정 알고리즘에 의해 변화 시키는 과정" 들의 모음으로 볼 수 있다. 이 "특정 알고리즘에 의해 변화 시키는 과정"을  **명령(Instruction)**또는 **구문(문장, Statement)**라 한다. 따라서 구문이 실행되는 것이고 실행 단위가 된다.

​	구문은 다음과 같은 것으로 구성된다.

1.  값(Value)
2. 연산자(Operator)
3. 표현식(Expression)
4. 예약어(Keyword)
5. 주석(Comment)

​	1.값과 2.연산자는 3.표현식을 구성할 수 있음을 이미 앞에서 살펴 보았다. 주석문이라 부르기도 하는 5.주석은 무시되며 실행 되지 않는다. 4.예약어로 우리에게 익숙한 다음과 같은 구문들을 작성할 수 있다.

2. if, if-else, if-else if
3. while
4. do-while
5. for
6. switch
7. for-in
8. with (deprecated)
9. debugger
10. 변수 선언(variable declaration)

​	프로그래밍 입문하면 보통 배우게 되는 가장 기본적인 구문들만 나열 하였다. 이외에도 함수정의, 블록({ }) 구문과 같이 다소 혼란스럽게 하는 구문들은 제외하였다.

#### 4.2 표현식의 실행	

​	JavaScript의 실행 단위는 구문이다. 엔진의 파서가 구문의 처음과 끝을 발견하면 즉시 그 구문을 실행한다. 표현식은 원칙적으로 실행 대상이 아니라 구문의 구성요소라고 위에서 언급하였듯시 구문에 포함되어 있는 표현식이 구문의 실행 시, 표현식이 표현하는 값으로 평가(evalue)될 뿐이다.

​	어디까지나 원칙이 그렇다는 것이고 실행되기도 한다. 하지만 구문 단위 실행의 원칙을 깨지 않는다. 즉, 표현식이 실행되는 것이 아니고 **표현식 구문(Expression Statement)**이 실행되는 것으로 이해해야 한다. 표현식 뒤에 `;` 를 붙히면 표현식 구문이 되어 실행된다. 앞의 3.1 리터럴과 식별자의 구분 : ex01.js 예제의 세 개의 라인은 모두 대입 연산자 표현식이며 뒤에 `;`를 붙혀 표현식 구문이 되어 각 라인마다 실행된다. 각 라인의 실행은 라인의 구문에 포함된 대입 연산자 표현식이 평가되는 것이 전부이지만 말이다.

​	그럼 첫 번째 라인의 `;`를 빼면 어떤 일이 벌어 지는 것인가? 그때는 1번 라인의 대입 연산자 표현식과 2번 라인의 대입 표현식 두 개가 평가되는 실행이 일어 난다. 즉, 두 개의 표현식이 있는 표현식 구문이 되는 것이다. 다음 예제를 보자.

```JavaScript
i = 10
j = 20;

i = 10, j =20;
```

 두 개의 표현식을 연결할 때는 , 를 사용하는데 1번 2번 라인은 3번과 동일하다고 볼 수 있다. 여기서 오해하지 말아야 할 것이 있다. 개행(line break)이 `,` 와 같다고 오해할 수 있는 데 그럴수도 있고 아닐 수도  있다.

​	 JavaScript 엔진은 공백을 기본적으로 무시하기 때문에  `,`를 사용하지 않으면 엔진은 3번 라인을 `1=10j=20;` 으로 인식해서 Syntax Error를 발생할 것이다. 따라서 `,`  로 두 표현식을 구분하는 역할을 한다.  다음 예제로 개행의 역할을 생각해 보자.

```JavaScript
i
=
10
```

​	저렇게 코딩할 일은 없지만 별 문제는 없는 코드다. 개행은 엔진이 무시 하지 않는다. 공백처럼 무시했다면 다음 코드는 잘 실행 될 것이다. 하지만 문법 오류가 발생하기 때문에 공백처럼 무시하지 않는다는 것을 알 수 있다.

```JavaScript
consol.lo
g('Hello World');
```

개행의 역할은 토큰의 분리이다. 사실 표현식은 토큰으로 더 쪼개져서 해석되어 지는데 i=10 표현식을 `i`, `=`, `10` 으로 쪼개어져 해석되어 진다. 위 예제는 쪼갤 필요없이 라인별로 토큰으로 해석되어 질 것이다.

​	` i = 10, j =20` 표현식 구문의 실행은 `i` , `=`,  `10` ,` j`, `=` , `20` 6개의 토큰으로 쪼개져서 순서대로 해석되어 지다가 10에서 하나의 표현식 평가가 완료되고 다시 20에서 하나의 표현식 평가가 될 것이다. `,`  는 하나의 라인에서 여러 표현식을 `,`로 분리하는 것 처럼 보이지만 사실은 완결된 표현식들을 연결하는 역할을 한다고 보면 된다. 따라서 다음 코드도 문법에 맞다.

```JavaScript
i = 10,j
= 20;
```

앞에 오류가 있었던 코드를 다음처럼 수정하면 실행이 잘 되는데,  여기서 알수 있는 사실이 있는데... 각자 알아서 생각해보자.

```JavaScript
console
.
log('Hello World');
```



### 5. var 그리고 let과 const

​	오래전 부터 있었던 var 키워드와 ES6에 추가된 let과 const 키워드는 변수의 선언 또는 정의를 하는 키워드이다. 그럼 변수의 정의와 선언의 차이점 부터 먼저 이해해야 한다.

#### 5.1 변수의 선언과 정의  : ex04.js 

```javascript
10;
x;
y = 10;
var z = 10;

console.log(y, z);
```

 1번 라인은 숫자 리터럴만 있는 구문이고 2번 라인은 식별자 표현식으로만 된 구문이다. 이 구문의 실행에서 존재하지 않는 변수 x가 있기 때문에 Reference Error 가 발생한다. 따라서, 변수를 구문에서 사용하기 전에는 반드시 변수를 선언 또는 정의해야 한다. JavaScript 에서는 `let`, `const`, `var` 키워드를 사용해 변수의 선언 또는 정의를 할 수 있다.

​	2번 라인은 변수에 값을 할당하지 않고 식별자로 변수의 이름만 부여 하였기 때문에 변수의 선언이 된다. 3번 라인은 식별자로 변수의 이름을 부여하고 그 이름에 값을 할당 하였기 때문에 변수의 정의가 된다.

​	출력 결과를 보면 y 가 `undefined` 로 출력된다.  [ch03/02. 데이터 타입](/kickscar-javascript/basic-practices/tree/master/ch03/02) 에서 다루는 내용이지만 `undefined`는 자바스크립트 기본 타입중에 하나로 값을 명시적으로 대입하지 않았지만 `undefined` 가 암시적으로 대입되었다. 아래 코드처럼 명시적 대입도 가능하지만 굳이 하지 않는다. 따라서 JavaScript에서는 변수의 선언과 변수의 정의를 구분하지 않는다. 즉, 2번 라인도 정의로 보는 것이 JavaScript에서는 맞다.

```javascript
var y = undefined;
```

​	일반적으로 프로그램 실행 흐름에서 변수를 정의하게 되면 변수가 그 때부터 존재하게 된다. 보통, 변수의 존재 범위를 스코프(Scope, 범위) 라고 한다. 소스 코드만 보면 변수가 어떤 스코프인 지 판단할 수 있는 스코프를 정적 스코프라 한다.  JavaScript는 정적 스코프이다.

​	문제는 소스 코드에 보이는 스코프와 프로그램 실행 흐름에서 생겨나는 스코프가 차이가 있다는 것이다. JavaScript 스코프는 처음부터 혼란스럽고 이해하기 만만치 않은 개념들도 있다. 자세한 내용은 [ch05 스코프(Scopre)](/kickscar-javascript/basic-practices/tree/master/ch05) 를 참고 한다.  JavaScript의 정적 스코프는 전역 스코프(Global Scope), 블록 스코프(Block Scope), 함수 스코프(Function Scope)에 적용된다.  변수는 이 세 가지 스코프를 가질 수 있다는 말이다.

​	`var` 키워드는 변수를 함수 내부(`{}` 블록 안) 에만 존재하는 함수 스코프를 가지도록 하는 키워드이다. 변수를 함수 내부에서 `var` 와 함께 정의하면,  함수 내부에서만 그 변수는 존재한다. `var`와 함께 정의하지 않으면 전역 스코프를 가져 프로그램 아무데서나 그 변수에 접근이 가능해지는 문제점을 낳게 한다.

`	var` 를 사용하지 않고 함수 내부에서 변수를 정의 했을 때 전역 스코프를 가지는 문제점과  `var` 의 작동 원리 Hoisting이 가지는 혼란스러움 때문에 ES6에서는 새롭게 `const`와 `let`을 사용하여 변수를 정의하도록 하였다. 이 두 키워드는 ES6 전까지는 없었던 블록 스코프를 가지도록 한다.

​	간단히 정리하면, `let`과 `const`를 사용해서 변수를 정의하라는 것이고 자세한 그 이유는 [ch05 스코프(Scopre)](/kickscar-javascript/basic-practices/tree/master/ch05) 참고한다. 두 키워드 중  `let`은 변수 정의에 사용한다. `const`는 정의한 후 값이 변하지 않는 상수 정의에 사용한다. 

#### 5.2 상수 정의 및 오류  : ex05.js

상수 정의 후, 값 대입을 다시 하면  Assignment to constant variable 오류가 발생한다.

```javascript
const n = 10;
n = 20;
```

![](http://image.kickscar.me:8080/markdown/javascript-practices/ch03-0001.png)

